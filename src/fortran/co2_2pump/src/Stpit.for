      SUBROUTINE STEPIT (FUNK)
      PARAMETER (NP = 30, NPP = NP + 1)
C
C  STEPIT 7.4        A.N.S.I. STANDARD FORTRAN        JUNE 1975
C  COPYRIGHT (C) 1965, 1975 J. P. CHANDLER
C       (PRESENT ADDRESS ....  COMPUTER SCIENCE DEPT.,
C              OKLAHOMA STATE UNIVERSITY, STILLWATER, OKLAHOMA 74074)
C
C  STEPIT FINDS LOCAL MINIMA OF A SMOOTH FUNCTION OF SEVERAL PARAMETERS.
C
C  -STEPIT IS A PHLEGMATIC METHOD OF SOLVING A PROBLEM.-
C            --  J. H. BURRILL, JR.,  360 STEPIT - A USER-S MANUAL
C
C  THIS SOURCE DECK AND A WRITE-UP ARE AVAILABLE FROM THE
C       QUANTUM CHEMISTRY PROGRAM EXCHANGE
C       DEPT. OF CHEMISTRY, INDIANA UNIVERSITY
C       BLOOMINGTON, INDIANA 47401
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  INPUT QUANTITIES.....  FUNK,NV,NTRAC,MATRX,MASK,X,XMAX,XMIN,
C                              DELTX,DELMN,NFMAX,NFLAT,KW
C  OUTPUT QUANTITIES....  X,FOBJ,ERR,       KFLAG,NOREP,KERFL
C
C     FUNK       --  THE NAME OF THE SUBROUTINE THAT COMPUTES FOBJ
C                         GIVEN X(1),X(2),...,X(NV) (EACH SUCH
C                         SUBROUTINE MUST BE NAMED IN AN EXTERNAL
C                         STATEMENT IN THE CALLING PROGRAM)
C     NV         --  THE NUMBER OF PARAMETERS, X
C     NTRAC      --  =0 FOR NORMAL OUTPUT, =+1 FOR TRACE OUTPUT,
C                         =-1 FOR NO OUTPUT
C     MATRX      --  =0 FOR NO ERROR CALCULATION, =100+M FOR ERROR
C                         CALCULATION USING STEPS 10**M TIMES LARGER
C                         THAN THE LAST STEPS USED IN THE MINIMIZATION
C     FOBJ       --  THE VALUE OF THE FUNCTION TO BE MINIMIZED
C     MASK(J)    --  NONZERO IF X(J) IS TO BE HELD FIXED
C     X(J)       --  THE J-TH PARAMETER
C     XMAX(J)    --  THE UPPER LIMIT ON X(J)
C     XMIN(J)    --  THE LOWER LIMIT ON X(J)
C     DELTX(J)   --  THE INITIAL STEP SIZE FOR X(J)
C     DELMN(J)   --  THE LOWER LIMIT (CONVERGENCE TOLERANCE) ON THE
C                         STEP SIZE FOR X(J)
C     ERR(J,K)   --  RETURNS THE ERROR MATRIX IF -MATRX- IS NONZERO
C                         (ERR IS ALSO USED FOR SCRATCH STORAGE)
C     NFMAX      --  THE MAXIMUM NUMBER OF FUNCTION COMPUTATIONS
C     NFLAT      --  NONZERO IF THE SEARCH IS TO TERMINATE WHEN ALL
C                         TRIAL STEPS GIVE IDENTICAL FUNCTION VALUES
C     JVARY      --  STEPIT SETS JVARY NONZERO IF X(JVARY) IS THE ONLY
C                         X(J) THAT HAS CHANGED SINCE THE LAST CALL TO
C                         FUNK (THIS CAN BE USED TO SPEED UP FUNK)
C     NXTRA      --  USED BY SUBROUTINE SIMPLEX BUT NOT BY STEPIT
C     KFLAG      --  RETURNED .GT. ZERO FOR A NORMAL EXIT,
C                         RETURNED .LT. ZERO FOR AN ABNORMAL EXIT
C     NOREP      --  RETURNED .GT. ZERO IF THE FUNCTION WAS NOT
C                         REPRODUCIBLE
C     KERFL      --  RETURNED .LT. ZERO IF SUBROUTINE STERR
C                         TERMINATED ABNORMALLY
C     KW         --  THE LOGICAL UNIT NUMBER OF THE PRINTER
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      EXTERNAL FUNK
C
C  THE FOLLOWING STATEMENTS CONVERT STEPIT TO DOUBLE PRECISION.
C  STEPIT CONTAINS NO MIXED MODE STATEMENTS, NO MATTER WHETHER THE
C  VARIABLES BEGINNING WITH A-H AND O-Z ARE ALL TYPE REAL OR ARE
C  ALL TYPE DOUBLE PRECISION.
C
C     DOUBLE PRECISION X,XMAX,XMIN,DELTX,DELMN,ERR,FOBJ,
C    X   VEC,DLX,XS,FSTOR,DX,SALVO,XOSC,FOSC,Q,STCUT,ACK,FACUP
C     DOUBLE PRECISION RZERO,RTEN,DELX,XPLUS,
C    X   FSAVE,FBEST,XSAVE,ADX,FPREV,DENOM,DEL,DXZ,DXU,DFZ,DFU,
C    X   AVEC,SUMV,CINDR,COXCM,COSIN,STEPS,FAC,QSQRT,DSQRT
C
C  THE DIMENSIONS OF ALL VECTORS AND MATRICES (AS OPPOSED TO ARRAYS)
C  ARE NV, EXCEPT FOR ....
C       ERR(NV,MOSQ),XOSC(NV,MOSQ),FOSC(MOSQ).
C  IF ERRORS ARE TO BE CALCULATED BY SUBROUTINE STERR, HOWEVER, THEN
C  ERR MUST BE DIMENSIONED AT LEAST     ERR(NV,MAX(NV,MOSQ)) .
C
      DIMENSION VEC(NP),FSTOR(NP),SALVO(NP),JFLAT(NP)
      DIMENSION XOSC(NP,5),FOSC(5)
C
C  IF UNLABELLED COMMON AND SINGLE PRECISION ARE USED AND THE EXTERNAL
C  FACILITY IS NOT USED, STEPIT IS THEN WRITTEN ENTIRELY IN
C  A.N.S.I. STANDARD BASIC FORTRAN.
C
C  USER COMMON.....
      COMMON /CSTEP/ X(NP),XMAX(NP),XMIN(NP),DELTX(NP),DELMN(NP),
     *     ERR(NP,NPP),FOBJ,NV,NTRAC,MATRX,MASK(NP),
     *     NFMAX,NFLAT,JVARY,NXTRA,KFLAG,NOREP,KERFL,KW
C
C  INTERNAL STEPIT COMMON.....
      COMMON /STORK/ DX(NP),XS(NP),DLX(NP),NACTV,NSSW,NF
C
C  SET THE LIBRARY FUNCTION FOR SINGLE PRECISION (SQRT) OR FOR
C  DOUBLE PRECISION (DSQRT).  NO OTHER FUNCTIONS ARE USED, EITHER
C  EXTERNAL OR INTRINSIC, EXCEPT THE ROUTINE INVOKED BY REAL**INTEGER.
C  THE ONLY SUBROUTINES CALLED ARE FUNK, STBEG, STERR, AND DATSW.
C  STEPIT TERMINATES IF SENSE SWITCH NUMBER -NSSW- IS ON.
C  THE STATEMENT    CALL DATSW(NSSW,JUMP)    RETURNS JUMP=1 IF
C  SENSE SWITCH NUMBER -NSSW- IS ON, AND JUMP=2 IF IT IS OFF.
C  IF NO SENSE SWITCH IS TO BE USED, SUPPLY A DUMMY ROUTINE FOR DATSW.
C
      QSQRT(Q)=SQRT(Q)
C     QSQRT(Q)=DSQRT(Q)
C
C  THE REAL FORMAT SPECIFICATIONS USED ARE E13.5, E16.8, E11.3, E23.15.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  CALL STBEG TO SET DEFAULT VALUES AND PRINT INITIAL OUTPUT.
C
      CALL STBEG (FUNK)
      IF(KFLAG)3710,2010,2010
C                            FSAVE ...  USED TO CHECK REPRODUCIBILITY
 2010 FSAVE=FOBJ
C
C  SET FIXED QUANTITIES ....
C
C                            MXSTP ...  LOG2(MAXIMUM NUMBER OF STEPS)
      MXSTP=5
C                            FACUP ...  IF MORE THAN FACUP STEPS ARE
C                                 TAKEN, THE STEP SIZE IS INCREASED
      FACUP=4.
C                            ACK ...  RATIO OF STEP SIZE INCREASE
      ACK=2.0
C                            STCUT ...  RATIO OF STEP SIZE DECREASE
      STCUT=10.
C                            MOSQ ...  MAXIMUM DEPTH OF OSCILLATION
C                                 SEARCH
      MOSQ=5
C                            MNOSC ...  MINIMUM OSCILLATION PERIOD
      MNOSC=2
C
      RZERO=0.
      RTEN=10.
C
C  NO REAL CONSTANTS ARE USED BEYOND THIS POINT.
C
      KERFL=0
C                            JOCK ...  SWITCH USED IN SETTING JVARY
      JOCK=1
C                            JUMP ...  FLAG SET BY SUBROUTINE DATSW
      JUMP=2
C                            NOSC ...  CURRENT DEPTH OF THE OSCILLATION
C                                 INFORMATION
      NOSC=0
C                            KWIT ...  TERMINATION SWITCH
      KWIT=0
C                            FBEST ...  BEST PREVIOUS VALUE OF FOBJ
      FBEST=FOBJ
      DO 2020 J=1,NV
C                            DX(J) ...  CURRENT STEP SIZE FOR X(J)
 2020   DX(J)=DELTX(J)
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  VARY THE PARAMETERS ONE AT A TIME.
C  THIS IS THE STARTING POINT USED EACH TIME THE STEP SIZE IS REDUCED
C  OR A SUCCESSFUL GIANT STEP IS COMPLETED.
C
C                            NCIRC ...  NUMBER OF CONSECUTIVE X(JX)
C                                 WITHOUT SIZABLE CHANGES
 2030 NCIRC=0
C                            NZIP ...  NUMBER OF CONSECUTIVE CYCLES
C                                 WITHOUT A GIANT STEP
      NZIP=0
C
C  MAIN DO LOOP FOR CYCLING THROUGH THE VARIABLES....
C  THE FIRST TRIAL STEP WITH EACH VARIABLE IS SEPARATE.
C
C                            NACK ...  NUMBER OF ACTIVE X(JX) CYCLED
C                                 THROUGH
 2040 NACK=0
      DO 3210 JX=1,NV
C                            JFLAT(JX) ...  NONZERO IF CHANGING X(JX)
C                                 DID NOT CHANGE FOBJ
        JFLAT(JX)=0
C                            VEC(J) ...  CURRENT VECTOR OF NUMBER OF
C                                 STEPS IN X(J)
        VEC(JX)=RZERO
C                            DLX(JX) ...  CHANGE IN X(JX)
        DLX(JX)=RZERO
        IF(MASK(JX))2050,2060,2050
 2050   VEC(JX)=-RZERO
        JFLAT(JX)=1
        GO TO 3190
 2060   NACK=NACK+1
C                            ADX=ABS(DX(JX))
        ADX=DX(JX)
        IF(ADX)2070,2080,2080
 2070   ADX=-ADX
C                            CHECK THAT DX(JX) IS NOT NEGLIGIBLE.
 2080   XSAVE=X(JX)
        XPLUS=XSAVE+DX(JX)
        IF(XPLUS-XSAVE)2090,2100,2090
 2090   XPLUS=XSAVE-DX(JX)
        IF(XPLUS-XSAVE)2110,2100,2110
 2100   JFLAT(JX)=2
        GO TO 2300
C                            STEP X(JX).
 2110   X(JX)=XSAVE+DX(JX)
        JVARY=0
        IF(JOCK)2130,2130,2120
 2120   JOCK=0
        JVARY=JX
C                            NFLAG ...  COUNTER USED IN SETTING JFLAG(J)
 2130   NFLAG=1
        IF(X(JX)-XMIN(JX))2150,2140,2140
 2140   IF(X(JX)-XMAX(JX))2160,2160,2150
 2150   NFLAG=NFLAG+3
        GO TO 2180
 2160   CALL FUNK
        NF=NF+1
        JVARY=JX
        FPREV=FOBJ
        IF(FOBJ-FBEST)2340,2170,2180
 2170   NFLAG=NFLAG+1
C                            STEP X(JX) THE OTHER WAY.
 2180   XPLUS=X(JX)
        X(JX)=XSAVE-DX(JX)
        IF(X(JX)-XMIN(JX))2310,2190,2190
 2190   IF(X(JX)-XMAX(JX))2200,2200,2310
 2200   CALL FUNK
        NF=NF+1
        JVARY=JX
        IF(FOBJ-FBEST)2330,2210,2220
 2210   NFLAG=NFLAG+1
 2220   IF(NFLAG-3)2230,2290,2310
C
C                            PERFORM PARABOLIC INTERPOLATION.
C
 2230   DENOM=(FOBJ-FBEST)-(FBEST-FPREV)
        IF(DENOM)2240,2310,2240
 2240   DLX(JX)=-DX(JX)*(FOBJ-FPREV)/(DENOM+DENOM)
        VEC(JX)=DLX(JX)/ADX
        X(JX)=XSAVE+DLX(JX)
        IF(X(JX)-XSAVE)2260,2250,2260
 2250   FOBJ=FBEST
        GO TO 2280
 2260   CALL FUNK
        NF=NF+1
        IF(FOBJ-FBEST)2270,2280,2280
 2270   FBEST=FOBJ
        JOCK=1
        GO TO 2320
 2280   DLX(JX)=RZERO
        VEC(JX)=RZERO
        GO TO 2310
 2290   JFLAT(JX)=1
 2300   VEC(JX)=-RZERO
 2310   X(JX)=XSAVE
 2320   NCIRC=NCIRC+1
        IF(NCIRC-NACTV)2450,3280,3280
C
C                            FLIP DX(JX) FOR MORE EFFICIENT OPERATION.
 2330   DX(JX)=-DX(JX)
C
C  A LOWER VALUE OF FOBJ HAS BEEN FOUND.  STEP, INCREASE THE STEP SIZE,
C  AND REPEAT AS LONG AS FOBJ DECREASES, UP TO MXSTP TIMES.
C
 2340   NCIRC=0
        NSTP=0
        DEL=DX(JX)
 2350   FPREV=FBEST
        FBEST=FOBJ
        VEC(JX)=VEC(JX)+DEL/ADX
        DLX(JX)=DLX(JX)+DEL
        NSTP=NSTP+1
        IF(NSTP-MXSTP)2360,2430,2430
 2360   DEL=ACK*DEL
        XPLUS=XSAVE
        XSAVE=X(JX)
        X(JX)=XSAVE+DEL
        IF(X(JX)-XMIN(JX))2440,2370,2370
 2370   IF(X(JX)-XMAX(JX))2380,2380,2440
 2380   CALL FUNK
        NF=NF+1
        IF(FOBJ-FBEST)2350,2390,2390
C
C                            PERFORM PARABOLIC INTERPOLATION.
 2390   DXZ=XSAVE-XPLUS
        DXU=X(JX)-XSAVE
        DFZ=FBEST-FPREV
        DFU=FOBJ-FBEST
        DENOM=DFZ*DXU-DFU*DXZ
        IF(DENOM)2400,2440,2400
 2400   DEL=(DFZ*DXU**2+DFU*DXZ**2)/(DENOM+DENOM)
        X(JX)=XSAVE+DEL
        IF(X(JX)-XSAVE)2410,2450,2410
 2410   CALL FUNK
        NF=NF+1
        IF(FOBJ-FBEST)2420,2440,2440
 2420   FBEST=FOBJ
        DLX(JX)=DLX(JX)+DEL
        VEC(JX)=VEC(JX)+DEL/ADX
 2430   JOCK=1
        GO TO 2450
 2440   X(JX)=XSAVE
C                            SEE IF THE STEP SIZE SHOULD BE INCREASED.
 2450   IF(NZIP)2460,2460,2470
 2460   IF(NACK-1)3190,3190,2470
 2470   AVEC=VEC(JX)
        IF(AVEC)2480,3190,2490
 2480   AVEC=-AVEC
 2490   IF(AVEC-FACUP)2560,2500,2500
C
C                            INCREASE THE STEP SIZE.
 2500   DX(JX)=DX(JX)*ACK
        VEC(JX)=VEC(JX)/ACK
        IF(NOSC)2530,2530,2510
 2510   DO 2520 J=1,NOSC
 2520     ERR(JX,J)=ERR(JX,J)/ACK
 2530   CONTINUE
        IF(NTRAC)2560,2560,2540
 2540   WRITE(KW,2550)JX,DX(JX)
 2550   FORMAT(/ 10H STEP SIZE I3, 14H INCREASED TO E13.5 )
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  STEP ALONG A RESULTANT DIRECTION, IF POSSIBLE.
C
 2560   IF(NZIP)3190,3190,2570
 2570   NONZR=0
        SUMV=RZERO
        DO 2590 J=1,NV
          IF(VEC(J))2580,2590,2580
 2580     NONZR=NONZR+1
 2590     SUMV=SUMV+VEC(J)**2
        IF(NONZR-2)3190,2600,2600
 2600   IF(SUMV)2810,2810,2610
C
C  GIANT STEPS WILL BE ATTEMPTED.  CHECK FOR POSSIBLE GIGANTIC STEPS.
C
 2610   IF(MOSQ)2810,2810,2620
 2620   CONTINUE
C
C X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
C
C  OSCILLATION SEARCH SECTION......
C
C                            KL ...  POINTER FOR OSCILLATION CHECK
        KL=1
C                            STORE OSCILLATION INFORMATION.
C                                 NOSC=MIN0(NOSC+1,MOSQ)
        NOSC=NOSC+1
        IF(NOSC-MOSQ)2660,2660,2630
 2630   NOSC=MOSQ
        IF(NOSC-1)2810,2660,2640
C
C                            THE QUEUE OF OSCILLATION INFORMATION IS
C                                 FULL.  PUSH IT DOWN, THROWING AWAY
C                                 THE OLDEST ITEM.
 2640   DO 2650 K=2,NOSC
          FOSC(K-1)=FOSC(K)
          DO 2650 J=1,NV
            XOSC(J,K-1)=XOSC(J,K)
 2650       ERR(J,K-1)=ERR(J,K)
C
C                            ADD THE NEW ITEM TO THE QUEUE.
 2660   SUMV=QSQRT(SUMV)
        DO 2670 J=1,NV
          XOSC(J,NOSC)=X(J)
 2670     ERR(J,NOSC)=VEC(J)/SUMV
        FOSC(NOSC)=FBEST
        IF(NOSC-2)2810,2680,2680
C
C  SEARCH FOR A PREVIOUS SUCCESSFUL GIANT STEP IN A DIRECTION MORE
C  NEARLY PARALLEL TO THE DIRECTION OF THE PROPOSED STEP THAN WAS THE
C  IMMEDIATELY PREVIOUS ONE.  THIS MAY MEAN THAT THE DIRECTIONS OF THE
C  GIANT STEPS OSCILLATE PERIODICALLY (ZIG-ZAG).  TRY GIGANTIC
C  (OSCILLATION) STEPS OF DECREASING PERIOD, THEN ORDINARY GIANT STEPS.
C  SINCE THE DIRECTIONS ARE GIVEN AS NUMBERS OF STEPS, THIS
C  PROCEDURE IS SCALE INDEPENDENT.
C
 2680   COXCM=RZERO
        DO 2690 J=1,NV
 2690     COXCM=COXCM+ERR(J,NOSC)*ERR(J,NOSC-1)
        NAH=NOSC-MNOSC
 2700   IF(KL-NAH)2710,2710,2810
 2710   DO 2750 K=KL,NAH
C                            NRETR ...  NUMBER OF OSCILLATION PERIODS
C                                 YET TO BE TESTED
          NRETR=NAH-K
          COSIN=RZERO
          DO 2720 J=1,NV
 2720       COSIN=COSIN+ERR(J,NOSC)*ERR(J,K)
          IF(K-(NOSC-1))2730,2760,2760
 2730     IF(COSIN)2750,2750,2740
 2740     IF(COSIN-COXCM)2750,2750,2760
 2750     CONTINUE
        GO TO 2810
C                            ZIG-ZAGGING DETECTED.  ATTEMPT TO TAKE
C                                 GIGANTIC STEPS.
 2760   KL=K+1
        IF(NTRAC)2790,2790,2770
 2770   NT=NOSC-K
        WRITE(KW,2780)NT,COXCM,COSIN
 2780   FORMAT(1X/1X, '********', 4X, ' GIGANTIC STEP WITH PERIOD ', 
     *     I2,' BEING ATTEMPTED.'/13X, ' COXCM, COSIN = ', 2E13.5)
 2790   DO 2800 J=1,NV
C                            SALVO ...  SAVES DLX DURING GIGANTIC STEPS
          SALVO(J)=DLX(J)
 2800     DLX(J)=X(J)-XOSC(J,K)
        FPREV=FOSC(K)
        GO TO 2820
C
C X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
C
C  SIMON SAYS, TAKE AS MANY GIANT STEPS AS POSSIBLE.
C
 2810   FPREV=FSTOR(JX)
C                            NRETR=-1 IF A GIANT STEP IS BEING TRIED.
        NRETR=-1
C                            NGIAN...  NUMBER OF GIANT OR GIGANTIC
C                                 STEPS COMPLETED
 2820   NGIAN=0
        NFSAV=NF
 2830   DO 2880 J=1,NV
          XS(J)=X(J)
          IF(MASK(J))2880,2840,2880
 2840     X(J)=X(J)+DLX(J)
C                            X(J)=AMAX1(AMIN1(X(J),XMAX(J)),XMIN(J))
          IF(X(J)-XMAX(J))2860,2860,2850
 2850     X(J)=XMAX(J)
 2860     IF(X(J)-XMIN(J))2870,2880,2880
 2870     X(J)=XMIN(J)
 2880     CONTINUE
        JOCK=0
        JVARY=0
        CALL FUNK
        NF=NF+1
        IF(FOBJ-FBEST)2890,2960,2960
 2890   FPREV=FBEST
        FBEST=FOBJ
        DO 2900 J=1,NV
 2900     DLX(J)=DLX(J)*ACK
        NGIAN=NGIAN+1
        IF(NTRAC)2830,2830,2910
 2910   IF(NGIAN-1)2920,2920,2950
 2920   WRITE(KW,2930)(VEC(J),J=1,JX)
 2930   FORMAT(/16H NO. OF STEPS = 9E11.3, /, (16X, 9E11.3))
        WRITE(KW,2940)FPREV,NFSAV,(XS(J),J=1,NV)
 2940   FORMAT(/ 7H FOBJ =, E16.8, 7X, 6H NF = ,I7, 15X, 9H X(J)...., /
     *       (1X, 7E16.8))
 2950   WRITE(KW,2940)FOBJ,NF,(X(J),J=1,NV)
        GO TO 2830
 2960   IF(NGIAN)3040,3040,2970
C
C                            PERFORM PARABOLIC INTERPOLATION.
C
 2970   DENOM=ACK*(FPREV-FBEST)-(FBEST-FOBJ)
        IF(DENOM)2980,3040,2980
 2980   CINDR=((FPREV-FBEST)*ACK+(FBEST-FOBJ)/ACK)/(DENOM+DENOM)
        DO 3030 J=1,NV
          IF(MASK(J))3030,2990,3030
 2990     X(J)=XS(J)+CINDR*DLX(J)
C
C                            X(J)=AMAX1(AMIN1(X(J),XMAX(J)),XMIN(J))
          IF(X(J)-XMAX(J))3010,3010,3000
 3000     X(J)=XMAX(J)
 3010     IF(X(J)-XMIN(J))3020,3030,3030
 3020     X(J)=XMIN(J)
 3030     CONTINUE
        JOCK=0
        JVARY=0
        CALL FUNK
        NF=NF+1
        IF(FOBJ-FBEST)3120,3040,3040
 3040   DO 3060 J=1,NV
          IF(NRETR)3060,3050,3050
 3050     DLX(J)=SALVO(J)
 3060     X(J)=XS(J)
        IF(NTRAC)3090,3090,3070
 3070   WRITE(KW,3080)FBEST,NGIAN,(X(J),J=1,NV)
 3080   FORMAT(// 7H FOBJ =, E16.8, 7H  AFTER, I3, 15H GIANT STEP(S).,
     *  10X, 9H X(J).... // (1X,7E16.8))
 3090   IF(NGIAN)3100,3100,3150
 3100   CONTINUE
C
C X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
C
C  STATEMENT USED IN THE OSCILLATION SEARCH....
C
        IF(NRETR)3170,3110,2700
C
C X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X
C
C                            IF ALL GIGANTIC STEPS WERE UNSUCCESSFUL,
C                                 TRY A GIANT STEP.
 3110   IF(NRETR)3170,2810,3170
C
 3120   FBEST=FOBJ
        JOCK=1
        IF(NTRAC)3150,3150,3130
 3130   STEPS=NGIAN
        STEPS=STEPS+CINDR
        WRITE(KW,3140)FBEST,STEPS,(X(J),J=1,NV)
 3140   FORMAT(//7H FOBJ =E16.8,7H  AFTER E11.3,13H GIANT STEPS.  4X,
     *       9H X(J).... // (1X, 7E16.8))
 3150   IF(NRETR)2030,3160,3160
 3160   CONTINUE
C                            A SUCCESSFUL GIGANTIC STEP HAS OCCURRED.
C                            INSERT ADDITIONAL LOGIC HERE IF DESIRED.
        GO TO 2030
C                            AN UNSUCCESSFUL GIANT STEP HAS OCCURRED.
C                                 DELETE ITS OSCILLATION INFORMATION.
C                                 NOSC=MAX0(NOSC-1,0)
 3170   NOSC=NOSC-1
        IF(NOSC)3180,3190,3190
 3180   NOSC=0
C                            COMPLETE THE MAIN DO LOOP.
C                            FSTOR(JX) ...  SAVES FBEST FOR
C                                 INTERPOLATION IN GIANT STEPS
 3190   FSTOR(JX)=FBEST
        CONTINUE
C                            RETURN IF THE SENSE SWITCH IS ON.
        CALL DATSW (NSSW,JUMP)
        IF(JUMP-1)3550,3550,3200
C
 3200   IF(NF-NFMAX)3210,3210,3530
 3210   CONTINUE
C                            END OF THE MAIN DO LOOP.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  ANOTHER CYCLE THROUGH THE VARIABLES HAS BEEN COMPLETED.
C  PRINT ANOTHER LINE OF TRACES.
C
      IF(NTRAC)3230,3230,3220
 3220 WRITE(KW,2930)(VEC(J),J=1,NV)
 3230 IF(NZIP)3270,3240,3270
 3240 CONTINUE
      IF(NTRAC)3270,3270,3250
 3250 WRITE(KW,2940)FBEST,NF,(X(J),J=1,NV)
      WRITE(KW,3260)
 3260 FORMAT(1H )
 3270 NZIP=NZIP+1
      GO TO 2040
C
C  A NEW BASE POINT HAS BEEN FOUND.  PRINT THE REMAINING TRACES.
C
 3280 FSTOR(JX)=FBEST
      IF(NTRAC)3300,3300,3290
 3290 WRITE(KW,2930)(VEC(J),J=1,JX)
      WRITE(KW,2940)FBEST,NF,(X(J),J=1,NV)
C
C  DECREASE THE SIZE OF THE STEPS FOR ALL VARIABLES.
C
 3300 CONTINUE
C                            RETURN IF THE SENSE SWITCH IS ON.
      CALL DATSW (NSSW,JUMP)
      IF(JUMP-1)3550,3550,3310
C
 3310 IF(NF-NFMAX)3320,3320,3530
C
C                            CHECK WHETHER ALL ABS(DX(J)) .LE. DELMN(J).
 3320 NGATE=1
      DO 3370 J=1,NV
        IF(MASK(J))3370,3330,3370
C
C                            IF(ABS(DX(J))-DELMN(J))
 3330   ADX=DX(J)
        IF(ADX)3340,3350,3350
 3340   ADX=-ADX
 3350   IF(ADX-DELMN(J))3370,3370,3360
 3360   NGATE=0
 3370   DX(J)=DX(J)/STCUT
      IF(NGATE)3410,3410,3380
 3380 KFLAG=1
      IF(NTRAC)3580,3390,3390
 3390 WRITE(KW,3400)
 3400 FORMAT(///31H TERMINATED WHEN THE STEP SIZES ,
     *   33H BECAME AS SMALL AS THE DELMN(J). )
      GO TO 3580
C                            CHECK THE JFLAT(J).
 3410 IF(NFLAT)3500,3500,3420
 3420 JFLMN=5
      DO 3450 J=1,NV
        IF(MASK(J))3450,3430,3450
 3430   IF(JFLAT(J)-JFLMN)3440,3450,3450
 3440   JFLMN=JFLAT(J)
 3450   CONTINUE
      IF(JFLMN-1)3500,3460,3460
 3460 KFLAG=2
      IF(NTRAC)3580,3470,3470
 3470 WRITE(KW,3480)
 3480 FORMAT(///36H TERMINATED WHEN THE FUNCTION VALUES ,
     *     36H AT ALL TRIAL POINTS WERE IDENTICAL.  )
      WRITE(KW,3490)(DX(J),J=1,NV)
 3490 FORMAT(///23H CURRENT STEP SIZES.... //(1X, 9E13.5))
      GO TO 3580
C                            PRINT THE DX(J) AND SEARCH SOME MORE.
 3500 CONTINUE
      IF(NTRAC)2030,2030,3510
 3510 WRITE(KW,3520)(DX(J),J=1,NV)
 3520 FORMAT(//60(2H *)//26H STEP SIZES REDUCED TO....//(1X, 9E13.5))
      GO TO 2030
C
 3530 KFLAG=-2
      WRITE(KW,3540)NFMAX
 3540 FORMAT(///46H ABNORMAL TERMINATION....   MORE THAN NFMAX = I7,
     *   30H CALLS TO THE FOBJ SUBROUTINE.)
      GO TO 3570
C
 3550 KFLAG=-3
      WRITE(KW,3560)NSSW
 3560 FORMAT(///40H ABNORMAL TERMINATION....  TERMINATED BY ,
     *   27H OPERATOR VIA SENSE SWITCH I2)
C
 3570 CONTINUE
      WRITE(KW,3490)(DX(J),J=1,NV)
C
C                            SET SWITCH FOR TERMINATION.
      KWIT=1
C                            CALL FUNK WITH THE BEST SET OF X(J).
 3580 JVARY=0
      CALL FUNK
      IF(FBEST-FSAVE)3590,3590,3600
 3590 IF(FOBJ-FBEST)3600,3620,3600
 3600 NOREP=NOREP+2
C      WRITE(KW,3610)NF,FSAVE,FBEST,FOBJ
 3610 FORMAT(////40H WARNING....  FOBJ IS NOT A REPRODUCIBLE ,
     *   18H FUNCTION OF X(J)., 7X, 6H NF = I5 // 5X, 3E23.15 )
 3620 CONTINUE
      IF(NTRAC)3650,3630,3630
 3630 WRITE(KW,3640)NF,FOBJ,(X(J),J=1,NV)
 3640 FORMAT(/////1X, I6,23H FUNCTION COMPUTATIONS ,
     *   ///23H FINAL VALUE OF FOBJ = E23.15
     *   /// 9X, 25H FINAL VALUES OF X(J).... // (1X, 5E23.15))
 3650 IF(KWIT)3710,3660,3710
C                            IF(IABS(MATRX-100)-50)
 3660 MATD=MATRX-100
      IF(MATD)3670,3680,3680
 3670 MATD=-MATD
 3680 IF(MATD-50)3690,3690,3710
C
C                            SET THE STEP SIZES FOR SUBROUTINE STERR.
 3690 FAC=RTEN**(MATRX-100)
      DO 3700 J=1,NV
 3700   DX(J)=FAC*DX(J)
C                            CALL STERR TO COMPUTE AN APPROXIMATE
C                                 ERROR MATRIX.
      CALL STERR (FUNK)
C                            THIS IS THE ONLY RETURN STATEMENT....
 3710 RETURN
C  END STEPIT.
      END
C
      SUBROUTINE STBEG (FUNK)
      PARAMETER (NP=30, NPP=NP+1)
C
C  STBEG 1.2        A.N.S.I. STANDARD FORTRAN        JUNE 1975
C  COPYRIGHT (C) 1965, 1975 J. P. CHANDLER
C
C  STBEG SETS DEFAULT VALUES AND PRINTS INITIAL OUTPUT FOR STEPIT.
C  THE CALL TO STBEG IS THE FIRST EXECUTABLE STATEMENT IN STEPIT, TO
C  FACILITATE OVERLAYING IF NECESSARY.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  INPUT QUANTITIES.....  FUNK,X,XMAX,XMIN,DELTX,DELMN,NV,NTRAC,
C                              MATRX,MASK,NFMAX,NFLAT,KW
C  OUTPUT QUANTITIES....  NSSW,NACTV,NF,KFLAG,NOREP,
C                              AND SOMETIMES X,XMAX,XMIN,DELTX,DELMN
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      EXTERNAL FUNK
C
C     DOUBLE PRECISION X,XMAX,XMIN,DELTX,DELMN,ERR,FOBJ,DX,XS,DLX
C     DOUBLE PRECISION HUGE,DELDF,RZERO,RUNIT,RTEN,RELAC,XPLUS,FSAVE,
C    *     UNITR
C
C  USER COMMON.....
      COMMON /CSTEP/ X(NP),XMAX(NP),XMIN(NP),DELTX(NP),DELMN(NP),
     *     ERR(NP,NPP),FOBJ,NV,NTRAC,MATRX,MASK(NP),
     *     NFMAX,NFLAT,JVARY,NXTRA,KFLAG,NOREP,KERFL,KW
C
C  INTERNAL STEPIT COMMON.....
      COMMON /STORK/ DX(NP),XS(NP),DLX(NP),NACTV,NSSW,NF
C
C  THE REAL FORMAT SPECIFICATIONS USED ARE E13.5, E23.15, E11.4, E18.10.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  SET FIXED QUANTITIES ....
C
C                            KTYPE ...  CONSOLE TYPEWRITER UNIT NUMBER
C                                 (IRRELEVANT IF A DUMMY DATSW IS USED)
      KTYPE=1
C                            NSSW ...  TERMINATION SENSE SWITCH NUMBER
C                                 (IRRELEVANT IF A DUMMY DATSW IS USED)
      NSSW=6
C                            HUGE ...  A VERY LARGE REAL NUMBER
C                                 (DEFAULT VALUE FOR XMAX AND -XMIN)
      HUGE=1.E35
C                            NVMAX ...  MAXIMUM VALUE OF NV
      NVMAX=NP
C                            DELDF ...  DEFAULT VALUE FOR DELTX(J)
      DELDF=.01
C
      RZERO=0.
      RUNIT=1
      UNITR=1
      RTEN=10.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  NO REAL CONSTANTS ARE USED BEYOND THIS POINT.
C  CHECK SOME INPUT QUANTITIES, AND SET THEM TO DEFAULT VALUES IF
C  DESIRED.
C
      KFLAG=0
      NOREP=0
C                            MAKE SURE THE SENSE SWITCH IS OFF.
      JUMP=2
      CALL DATSW (NSSW,JUMP)
      IF(JUMP-1)1010,1010,1040
C
C                            ONLY USAGE OF THE CONSOLE TYPEWRITER....
 1010 CONTINUE
      WRITE(KTYPE,1020)NSSW
 1020 FORMAT(/23H TURN OFF SENSE SWITCH I2//1H )
 1030 CALL DATSW (NSSW,JUMP)
      IF(JUMP-1)1030,1030,1040
C
C  COMPUTE RELAC, THE RELATIVE PRECISION OF THE MACHINE AND ARITHMETIC
C  BEING USED.  RELAC IS USED IN SETTING DELMN(J) TO A DEFAULT VALUE.
C
 1040 RELAC=RUNIT
 1050 RELAC=RELAC/RTEN
      XPLUS=RUNIT+RELAC
      IF(XPLUS-UNITR)1060,1060,1050
C
C                            NACTV ...  NUMBER OF ACTIVE X(J)
 1060 NACTV=0
      FOBJ=RZERO
      IF(NV)1250,1250,1070
 1070 IF(NV-NVMAX)1080,1080,1250
 1080 DO 1240 J=1,NV
        IF(MASK(J))1240,1090,1240
C
C                            CHECK THAT DELTX(J) IS NOT NEGLIGIBLE.
 1090   IF(DELTX(J))1100,1120,1100
 1100   XPLUS=X(J)+DELTX(J)
        IF(XPLUS-X(J))1110,1120,1110
 1110   XPLUS=X(J)-DELTX(J)
        IF(XPLUS-X(J))1150,1120,1150
 1120   IF(X(J))1130,1140,1130
 1130   DELTX(J)=DELDF*X(J)
        GO TO 1150
 1140   DELTX(J)=DELDF
 1150   IF(DELMN(J))1170,1160,1180
 1160   DELMN(J)=DELTX(J)*RELAC
        IF(DELMN(J))1170,1180,1180
 1170   DELMN(J)=-DELMN(J)
 1180   IF(XMAX(J)-XMIN(J))1190,1190,1200
 1190   XMAX(J)=HUGE
        XMIN(J)=-HUGE
 1200   NACTV=NACTV+1
C                            X(J)=AMAX1(XMIN(J),AMIN1(XMAX(J),X(J)))
        IF(X(J)-XMAX(J))1220,1220,1210
 1210   X(J)=XMAX(J)
 1220   IF(X(J)-XMIN(J))1230,1240,1240
 1230   X(J)=XMIN(J)
 1240   CONTINUE
C
      IF(NACTV)1250,1250,1260
 1250 KFLAG=-1
      GO TO 1390
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
 1260 CONTINUE
      IF(NTRAC)1350,1270,1270
 1270 WRITE(KW,1280)
 1280 FORMAT( 54H1SUBROUTINE STEPIT.  COPYRIGHT (C) 1965 J. P. CHANDLER,
     *     // 19H INITIAL VALUES....  / 1H  )
      WRITE(KW,1290)(MASK(J),J=1,NV)
 1290 FORMAT(/10H MASK   =  I7,7I13/(4X, 8I13))
      WRITE(KW,1300)(X(J),J=1,NV)
 1300 FORMAT(/10H X      =  8E13.5/(10X, 8E13.5))
      WRITE(KW,1310)(XMAX(J),J=1,NV)
 1310 FORMAT(/10H XMAX   =  8E13.5/(10X, 8E13.5))
      WRITE(KW,1320)(XMIN(J),J=1,NV)
 1320 FORMAT(/10H XMIN   =  8E13.5/(10X, 8E13.5))
      WRITE(KW,1330)(DELTX(J),J=1,NV)
 1330 FORMAT(/10H DELTX  =  8E13.5/(10X, 8E13.5))
      WRITE(KW,1340)(DELMN(J),J=1,NV)
 1340 FORMAT(/10H DELMN  =  8E13.5/(10X, 8E13.5))
C
 1350 JVARY=0
      CALL FUNK
      FSAVE=FOBJ
      CALL FUNK
C                            NF ...  NUMBER OF CALLS TO FUNK
      NF=2
      IF(FOBJ-FSAVE)1360,1380,1360
 1360 NOREP=1
C      WRITE(KW,1370)NF,FSAVE,FOBJ
 1370 FORMAT(////40H WARNING....  FOBJ IS NOT A REPRODUCIBLE ,
     *   18H FUNCTION OF X(J). 7X, 6H NF = I5 // 5X, 3E23.15 )
C
 1380 CONTINUE
      IF(NTRAC)1440,1390,1390
 1390 CONTINUE
      WRITE(KW,1400)NV,NACTV,MATRX,NFMAX,NFLAT,RELAC,FOBJ
 1400 FORMAT(//1X, I2, ' VARIABLES, ' I2, ' ACTIVE.', 9X, ' MATRX = ',
     *   I4, 9X, 'NFMAX = ', I8/1X, 'NFLAT = ', I2, 9X, ' RELAC = ',
     *   E11.4,///1X, 'FOBJ = ', E18.10///1X, 'BEGIN MINIMIZATION....',
     *   ///1X)
C
 1440 RETURN
C  END STBEG.
      END
C
      SUBROUTINE STERR (FUNK)
      PARAMETER (NP=30, NPP=NP+1)
C
C  STERR 1.3       A.N.S.I. STANDARD FORTRAN       JUNE 1975
C  COPYRIGHT (C) 1965, 1975 J. P. CHANDLER
C
C  STERR IS CALLED BY STEPIT TO COMPUTE AN APPROXIMATE ERROR MATRIX
C  FOR A NONLINEAR FITTING PROBLEM.
C  THE VALUES COMPUTED ARE OFTEN POOR APPROXIMATIONS.  FOR EACH CLASS
C  OF PROBLEMS THEY SHOULD BE CHECKED USING SUBROUTINE FIDO.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  INPUT QUANTITIES.....  FUNK,KW,NSSW,DX,NF,X,NTRAC,NV
C  OUTPUT QUANTITIES....  NF,ERR,KERFL, AND SOMETIMES DX
C  SCRATCH STORAGE......  XS,DLX
C
C  THE DX(J) ARE THE STEP SIZES USED IN APPROXIMATING THE SECOND
C  PARTIAL DERIVATIVES OF FOBJ WITH RESPECT TO THE X(J) BY FINITE
C  DIFFERENCES.
C  ERR RETURNS THE ERROR MATRIX.
C  XMAX, XMIN, AND MASK ARE IGNORED IN STERR.
C  THE REAL FORMAT SPECIFICATIONS USED ARE E13.5, E16.8, AND E23.15 .
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      EXTERNAL FUNK
C
C     DOUBLE PRECISION X,XMAX,XMIN,DELTX,DELMN,ERR,FOBJ,DX,XS,DLX,
C    X   SECND,FBEST,RZERO,RUNIT,RTWO,ABER,DENOM
C     DOUBLE PRECISION P,Q,QSQRT,DSQRT,DXDEF
C
      DIMENSION SECND(2,2)
C
C  USER COMMON.....
      COMMON /CSTEP/ X(NP),XMAX(NP),XMIN(NP),DELTX(NP),DELMN(NP),
     *     ERR(NP,NPP),FOBJ,NV,NTRAC,MATRX,MASK(NP),
     *     NFMAX,NFLAT,JVARY,NXTRA,KFLAG,NOREP,KERFL,KW
C
C  INTERNAL STEPIT COMMON.....
      COMMON /STORK/ DX(NP),XS(NP),DLX(NP),NACTV,NSSW,NF
C
C  XS AND DLX ARE IN COMMON ONLY TO CONSERVE STORAGE.
C
      QSQRT(Q)=SQRT(Q)
C     QSQRT(Q)=DSQRT(Q)
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C                            DXDEF ...  DEFAULT VALUE FOR DX
      DXDEF=.001
      RZERO=0.
      RUNIT=1.
      RTWO=2.
C
C  NO REAL CONSTANTS ARE USED BEYOND THIS POINT.
C
      KERFL=0
      DO 5050 K=1,NV
        IF(MASK(K))5050,5010,5050
 5010   IF(DX(K))5040,5020,5050
 5020   DX(K)=DXDEF*X(K)
        IF(DX(K))5040,5030,5050
 5030   DX(K)=DXDEF
        GO TO 5050
 5040   DX(K)=-DX(K)
 5050   XS(K)=X(K)
      CALL FUNK
      NF=NF+1
      FBEST=FOBJ
      IF(NTRAC)5090,5060,5060
 5060 WRITE(KW,5070)
 5070 FORMAT(49H1COMPUTE AN APPROXIMATE ERROR MATRIX USING FINITE ,
     *   13H DIFFERENCES.////34H INCREMENTS IN X(J) TO BE USED.... )
      WRITE(KW,5080)(DX(K),K=1,NV)
 5080 FORMAT(/(9X, 8E13.5))
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  APPROXIMATE THE (SYMMETRIC) MATRIX OF SECOND PARTIAL DERIVATIVES
C  OF FOBJ WITH RESPECT TO THE X(J), USING FINITE DIFFERENCES.
C
C                            COMPUTE THE DIAGONAL PARTIALS FIRST.
 5090 DO 5120 J=1,NV
        ERR(J,J)=RZERO
        IF(MASK(J))5120,5100,5120
 5100   JVARY=0
        DO 5110 K=1,2
          X(J)=XS(J)+DX(J)
          CALL FUNK
          NF=NF+1
          JVARY=J
          SECND(K,1)=FOBJ
 5110     DX(J)=-DX(J)
        X(J)=XS(J)
        ERR(J,J)=((SECND(1,1)-FBEST)-(FBEST-SECND(2,1)))/DX(J)**2
 5120   CONTINUE
C                            COMPUTE THE OFF-DIAGONAL PARTIALS.
      IF(NV-2)5210,5130,5130
 5130 DO 5200 J=2,NV
        JMU=J-1
        DO 5190 K=1,JMU
          ERR(J,K)=RZERO
          IF(MASK(J))5190,5140,5190
 5140     IF(MASK(K))5190,5150,5190
 5150     DO 5180 L=1,2
            X(J)=XS(J)+DX(J)
            JVARY=0
            DO 5160 M=1,2
              X(K)=XS(K)+DX(K)
              CALL FUNK
              NF=NF+1
              JVARY=K
              SECND(L,M)=FOBJ
              X(K)=XS(K)
 5160         DX(K)=-DX(K)
            X(J)=XS(J)
C                            RETURN IF THE SENSE SWITCH IS ON.
            JUMP=2
            CALL DATSW (NSSW,JUMP)
            IF(JUMP-1)5170,5170,5180
 5170       KERFL=-1
            GO TO 5800
C
 5180       DX(J)=-DX(J)
          ERR(J,K)=((SECND(1,1)-SECND(1,2))-(SECND(2,1)-SECND(2,2)))/
     *        (RTWO*DX(J)*RTWO*DX(K))
 5190     CONTINUE
 5200   CONTINUE
C                            END OF THE DERIVATIVE COMPUTATION.
 5210 CONTINUE
      IF(NTRAC)5280,5220,5220
 5220 WRITE(KW,5230)(K,K=1,NV)
 5230 FORMAT(//////45H MATRIX OF THE SECOND PARTIAL DERIVATIVES....///
     *   12X, 7H K .... I5, 7I13 / (11X, 8I13))
      WRITE(KW,5240)(MASK(K),K=1,NV)
 5240 FORMAT(/1X, 'MASK(K)....'//(1X, 15I5))
      WRITE(KW,5250)
 5250 FORMAT(//3X, 1HJ 4X, 7HMASK(J))
      DO 5270 J=1,NV
        WRITE(KW,5260)J,MASK(J),(ERR(J,K),K=1,J)
 5260   FORMAT(/ 1X, I3, I8, 5X, 8E13.5 / (17X, 8E13.5))
 5270   CONTINUE
C                            PACK THE MATRIX OF SECOND DERIVATIVES.
 5280 NACTV=0
      DO 5330 J=1,NV
        IF(MASK(J))5330,5290,5330
 5290   NACTV=NACTV+1
        KACT=0
        DO 5320 K=1,J
          IF(MASK(K))5320,5300,5320
 5300     KACT=KACT+1
          ERR(NACTV,KACT)=ERR(J,K)
          IF(ERR(J,K))5320,5310,5320
 5310     KERFL=1
 5320     CONTINUE
 5330   CONTINUE
      IF(KERFL)5360,5360,5340
 5340 CONTINUE
      WRITE(KW,5350)
 5350 FORMAT(////38H THE ABOVE MATRIX CONTAINS ONE OR MORE ,
     *   19H UNEXPECTED ZEROES./34H PERHAPS A LARGER VALUE OF -MATRX- ,
     *   48H SHOULD BE TRIED, TO SEE IF THEY ARE LEGITIMATE. )
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  INVERT THE MATRIX OF SECOND PARTIAL DERIVATIVES USING THE GAUSS-
C  JORDAN METHOD (F. L. BAUER AND C. REINSCH, P. 45 IN -LINEAR ALGEBRA-
C  BY J. H. WILKINSON AND C. REINSCH (SPRINGER-VERLAG, 1971)).
C  ONLY THE LOWER TRIANGLE OF ERR IS USED OR ALTERED.
C
C                            NOTPD ...  =1 IF THE MATRIX IS NOT
C                                 POSITIVE DEFINITE
 5360 NOTPD=0
      DO 5490 LL=1,NACTV
        L=NACTV+1-LL
        P=ERR(1,1)
        IF(P)5390,5370,5400
 5370   KERFL=-2
        WRITE(KW,5380)
 5380   FORMAT(////39H A PIVOT ELEMENT OF THE MATRIX IS ZERO. ,
     *       38H  PERHAPS -MATRX- SHOULD BE INCREASED.   ////1H )
        GO TO 5800
 5390   NOTPD=1
 5400   IF(NACTV-2)5460,5410,5410
 5410   DO 5450 K=2,NACTV
          Q=ERR(K,1)
          IF(K-L)5430,5430,5420
 5420     XS(K)=Q/P
          GO TO 5440
 5430     XS(K)=-Q/P
 5440     DO 5450 M=2,K
 5450       ERR(K-1,M-1)=ERR(K,M)+Q*XS(M)
 5460   ERR(NACTV,NACTV)=RUNIT/P
        IF(NACTV-2)5490,5470,5470
 5470   DO 5480 K=2,NACTV
 5480     ERR(NACTV,K-1)=XS(K)
 5490   CONTINUE
C
      IF(NOTPD)5520,5520,5500
 5500 KERFL=-3
      WRITE(KW,5510)
 5510 FORMAT(////44H THE ERROR MATRIX IS NOT POSITIVE DEFINITE. ,
     *     37H PERHAPS -MATRX- SHOULD BE DECREASED.   )
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  UNPACK, DOUBLE, AND SYMMETRIZE THE INVERSE TO FORM THE ERROR MATRIX.
C
 5520 JACT=NACTV
      DO 5580 JJ=1,NV
        J=NV+1-JJ
        KACT=JACT
        DO 5560 KK=1,J
          K=J+1-KK
          IF(MASK(J))5540,5530,5540
 5530     IF(MASK(K))5540,5550,5540
 5540     ERR(J,K)=RZERO
          GO TO 5560
 5550     ERR(J,K)=ERR(JACT,KACT)*RTWO
          KACT=KACT-1
 5560     ERR(K,J)=ERR(J,K)
        IF(MASK(J))5580,5570,5580
 5570   JACT=JACT-1
 5580   CONTINUE
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  PRINT THE ERRORS AND CORRELATIONS, AND RETURN.
C
C                            COMPUTE AND PRINT THE STANDARD ERRORS.
      IF(NTRAC)5610,5590,5590
 5590 WRITE(KW,5600)
 5600 FORMAT(////// 32H APPROXIMATE STANDARD ERRORS.... ///
     *   12X, 1HJ, 6X, 7HMASK(J) 9X, 4HX(J) 14X, 5HERROR )
 5610 DO 5710 J=1,NV
        ABER=ERR(J,J)
        IF(ABER)5620,5680,5630
 5620   ABER=-ABER
 5630   ABER=QSQRT(ABER)
        IF(MASK(J))5680,5640,5680
 5640   IF(ERR(J,J))5650,5660,5680
 5650   ABER=-ABER
 5660   KERFL=-4
        WRITE(KW,5670)ERR(J,J)
 5670   FORMAT( ///29H NEGATIVE OR ZERO MEAN SQUARE ,
     *       22H ERROR ENCOUNTERED.... 3X, E16.8/
     *       37H PERHAPS -MATRX- SHOULD BE DECREASED. ///1H )
 5680   CONTINUE
        IF(NTRAC)5710,5690,5690
 5690   WRITE(KW,5700)J,MASK(J),X(J),ABER
 5700   FORMAT(/10X, I3, I10, 6X, E16.8, 4X, E13.5)
 5710   XS(J)=ABER
C                            COMPUTE AND PRINT THE CORRELATIONS.
      IF(NTRAC)5800,5720,5720
 5720 IF(NV-2)5800,5730,5730
 5730 CONTINUE
      WRITE(KW,5740)(K,K=1,NV)
 5740 FORMAT(//////45H LOWER TRIANGLE OF THE CORRELATION MATRIX....///
     *   12X, 7H K .... I5, 7I13 / (11X, 8I13))
      WRITE(KW,5240)(MASK(K),K=1,NV)
      WRITE(KW,5250)
      DO 5790 J=1,NV
        DO 5780 K=1,J
          DENOM=XS(J)*XS(K)
          IF(DENOM)5760,5750,5770
 5750     DLX(K)=RZERO
          GO TO 5780
 5760     DENOM=-DENOM
 5770     DLX(K)=ERR(J,K)/DENOM
 5780     CONTINUE
 5790   WRITE(KW,5260)J,MASK(J),(DLX(K),K=1,J)
C
 5800 JVARY=0
      CALL FUNK
      NF=NF+1
      IF(NTRAC)5830,5810,5810
 5810 WRITE(KW,5820)NF,FOBJ,(X(J),J=1,NV)
 5820 FORMAT(///// 1X, I6, 23H FUNCTION COMPUTATIONS ///
     *   23H FINAL VALUE OF FOBJ = E23.15 ///
     *   9X, 25H FINAL VALUES OF X(J).... // (1X, 5E23.15))
 5830 RETURN
C  END STERR.
      END
C
      SUBROUTINE DATSW (NSSW,JUMP)
C
C  DUMMY VERSION OF SUBROUTINE DATSW (ALL SWITCHES PERMANENTLY OFF).
C
      JUMP=2
      RETURN
      END
C
      SUBROUTINE FIDO (FUNK,JX,STDVS,TOL,EGUES,MXIND,FDINT)
      PARAMETER (NP=30, NPP=NP+1)
C
C  FIDO 4.3        A.N.S.I. STANDARD FORTRAN        JUNE 1975
C
C  COPYRIGHT (C) 1966 J. P. CHANDLER
C  (PRESENT ADDRESS...  COMPUTER SCIENCE DEPT., OKLAHOMA STATE U.)
C
C  SUBROUTINE FIDO IS USED IN CONJUNCTION WITH STEPIT TO COMPUTE
C  APPROXIMATE CONFIDENCE HALF-INTERVALS (-ERRORS-) FOR PARAMETERS IN A
C  CURVE FITTING PROBLEM, USING THE METHOD OF SUPPORT PLANES.
C  THE QUANTITY BEING MINIMIZED (FOBJ) MUST EITHER BE CHI-SQUARE OR IT
C  MUST BE TWICE THE NEGATIVE OF THE LOGARITHM OF THE LIKELIHOOD
C  FUNCTION.
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  USAGE......
C  FIRST CALL STEPIT TO FIND THE OPTIMUM VALUES OF THE PARAMETERS.
C  THEN CALL FIDO ONCE FOR EACH PARAMETER FOR WHICH THE CONFIDENCE
C  INTERVALS ARE DESIRED.
      INTEGER J
C
C  INPUT QUANTITIES.....   FUNK,JX,STDVS,TOL,EGUES,MXIND,X( ),KW
C  OUTPUT QUANTITY......   FDINT( )
C
C     FUNK      --  THE NAME OF THE SUBROUTINE WHICH COMPUTES FOBJ
C                        GIVEN THE VALUES OF THE X(J)
C
C     JX        --  THE INDEX OF THE PARAMETER, X(JX), FOR WHICH
C                        CONFIDENCE HALF-INTERVALS ARE TO BE COMPUTED
C
C     STDVS     --  THE NUMBER OF STANDARD DEVIATIONS TO WHICH THE
C                        HALF-INTERVALS ARE TO CORRESPOND
C
C     TOL       --  CONVERGENCE TOLERANCE (USE TOL=.05)
C
C     EGUES     --  ROUGH ESTIMATE OF THE LENGTH OF THE HALF-INTERVALS
C
C     MXIND     --  =1 TO COMPUTE THE HALF-INTERVAL WITH THE SAME
C                        SIGN AS EGUES,
C                   =2 TO COMPUTE BOTH HALF-INTERVALS
C
C     X( )      --  THE POSITION OF THE MINIMUM OF FOBJ
C
C     KW        --  THE LOGICAL UNIT NUMBER OF THE PRINTER
C
C     FDINT(J)  --  RETURN THE COMPUTED LENGTHS OF THE HALF-INTERVALS
C
      INTEGER K
C  IF STEPIT COMPUTES THE ERROR MATRIX ERR, EGUES CAN BE SET
C  TO PLUS OR MINUS    STDVS*SQRT(ERR(JX,JX)) (SEE BELOW).
C
C  TO OBTAIN PRINTOUT FROM STEPIT, SET NTRST=0 BELOW.
C
C  EXAMPLE OF USAGE (CALCULATION OF THE ERROR IN X(3))....
C
C     EXTERNAL FSUB
C     DIMENSION FDINT(2)
C       ..........
C     CALL STEPIT(FSUB)
C     EGUES=SQRT(ERR(3,3))
C     CALL FIDO (FSUB,3,1.,.05,EGUES,2,FDINT)
C
C  NOTE ....  FIDO CALLS STEPIT, WHICH MAY USE THE ARRAY ERR FOR SCRATCH
C                  STORAGE, DESTROYING ITS CONTENTS.....................
      INTEGER NV
C
C  FOR A LEAST SQUARES PROBLEM,
C
C                          NPTS
C     FOBJ = CHI-SQUARE =  SUM  ((FIT(JPT)-YDATA(JPT))/YSIGMA(JPT))**2
C                         JPT=1
C
C  THE STANDARD ERRORS YSIGMA( ) MUST BE CORRECTLY SCALED.  IF THEY
C  ARE NOT KNOWN, NORMALIZE THEM SO THAT THE VALUE OF FOBJ AT THE
C  MINIMUM IS EQUAL TO THE NUMBER OF DEGREES OF FREEDOM,
C     N.D.F. = ((NO. DATA POINTS) - (NO. ADJUSTABLE PARAMETERS)) .
C
C  FIDO IS ESSENTIALLY A ROOT FINDING ROUTINE.  IT USES INVERSE
C  QUADRATIC INTERPOLATION OR EXTRAPOLATION, INVERSE LINEAR
C  INTERPOLATION, AND BISECTION (INTERVAL HALVING), AS SUCCESSIVELY
C  MORE DIFFICULTIES IN FINDING THE ROOT ARE ENCOUNTERED.
      INTEGER JJ
C
C  PRIMARY REFERENCES....
C
C       W. T. EADIE ET AL., -STATISTICAL METHODS IN EXPERIMENTAL
C            PHYSICS- (AMERICAN ELSEVIER, 1971), CHAPTER 9
C
C       P. R. BEVINGTON, -DATA REDUCTION AND ERROR ANALYSIS IN THE
C            PHYSICAL SCIENCES- (MCGRAW-HILL, 1969), PAGES 242-245
C
C  OTHER REFERENCES....
C
C       H. SCHEFFE, -THE ANALYSIS OF VARIANCE- (WILEY, 1959)
C       H. STONE, DISCUSSION ON PAPER BY E. M. L. BEALE,
C            J. ROY. STATIS. SOC. B., V. 22 (1960), P. 41, P. 84, 85.
C       G. E. P. BOX AND G. A. COUTIE, PROC. INST. ELEC. ENGRS.
C            V. 103, PART B, SUPPL. NO. 1 (1956).
C       G. W. BOOTH, G. E. P. BOX, M. E. MULLER, AND T. I. PETERSON,
C            -FORECASTING BY GENERALIZED REGRESSION METHODS, NON-LINEAR
C            ESTIMATION- (PRINCETON-IBM), FEB. 1959, IBM MANUAL.
C       D. W. MARQUARDT, -LEAST-SQUARES ESTIMATION OF NONLINEAR
C            PARAMETERS-, SHARE DISTRIBUTION 3094
C       D. W. MARQUARDT, R. G. BENNETT, AND E. J. BURRELL, -LEAST
C            SQUARES ANALYSIS OF ELECTRON PARAMAGNETIC RESONANCE
C            SPECTRA-, J. OF MOLECULAR SPECTROSCOPY 7 (1961) 269
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      EXTERNAL FUNK
C
C     DOUBLE PRECISION STDVS,TOL,EGUES,FDINT,XSAVE,XKA,XKB
C     DOUBLE PRECISION FOBJ,X,XMAX,XMIN,DELTX,DELMN,ERR
C     DOUBLE PRECISION FSAVE,T,DABS,DSQRT,ARG,QSQRT
C     DOUBLE PRECISION RSMAL,CONV,BRACK,FACMX,FRMIN,RZERO,RHALF,
C    X   RUNIT,FPU,SGN,FB,FC,DX,DC,DIFF,FKA,FKB,FAC,
C    X   XX,FRAC,FTABS,XBEST,FBEST,TOLF,STDEV,ERG
C
      DIMENSION FDINT(2)
      DIMENSION XSAVE(NP),XKA(NP),XKB(NP),XBEST(NP)
C
C  IF UNLABELLED COMMON AND SINGLE PRECISION ARE USED AND THE EXTERNAL
C  FACILITY IS NOT USED, SUBROUTINE FIDO IS THEN WRITTEN ENTIRELY IN
C  A.N.S.I. STANDARD BASIC FORTRAN.
C
      COMMON /CSTEP/ X(NP),XMAX(NP),XMIN(NP),DELTX(NP),DELMN(NP),
     *     ERR(NP,NPP),FOBJ,NV,NTRAC,MATRX,MASK(NP),
     *     NFMAX,NFLAT,JVARY,NXTRA,KFLAG,NOREP,KERFL,KW
C
C                            SET THE LIBRARY FUNCTIONS FOR SINGLE
C                                 PRECISION OR FOR DOUBLE PRECISION.
      QSQRT(ARG)= SQRT(ARG)
C     QSQRT(ARG)=DSQRT(ARG)
      T(ARG)= ABS( SQRT(ARG-FSAVE)-STDEV)
C     T(ARG)=DABS(DSQRT(ARG-FSAVE)-STDEV)
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C  SET SOME PARAMETERS.
C                            RSMAL ...  USED IN SETTING PHONY VALUE IF
C                                 FOBJ BELOW -GLOBAL MINIMUM- IS FOUND
      RSMAL=.0001
C                            NTRST ...  VALUE OF NTRAC TO BE USED IN
C                                 STEPIT WHEN FIDO CALLS IT
      NTRST=-1
C                            CONV ...  SATISFACTORY RATE OF CONVERGENCE
      CONV=.5
C                            BRACK ...  FACTOR FOR BRACKETTING SHOTS
      BRACK=2.
C                            NTRY ...  MAXIMUM NUMBER OF ITERATIONS
      NTRY=20
C                            FACMX ...  MAXIMUM FACTOR FOR PARABOLIC
C                                 INTERPOLATION
      FACMX=4.
C                            FRMIN ...  MINIMUM FRACTION FOR LINEAR
C                                 INTERPOLATION
      FRMIN=.1
C
      RZERO=0.
      RHALF=.5
      RUNIT=1.
C
C  SAVE SOME INPUT QUANTITIES, AND INITIALIZE EVERYTHING.
C
      JFID=JX
      TOLF=TOL
      STDEV=STDVS
      NS=NTRAC
      MATS=MATRX
      NTRAC=NTRST
      MATRX=0
      MS=MASK(JFID)
      MASK(JFID)=1
      NACTV=0
      DO 6020 J=1,NV
        XBEST(J)=X(J)
        XSAVE(J)=X(J)
        IF(MASK(J))6020,6010,6020
 6010   NACTV=NACTV+1
 6020   CONTINUE
      CALL FUNK
      FSAVE=FOBJ
      FBEST=FOBJ
      FPU=FOBJ+STDEV**2
      ERG=EGUES
      X(JFID)=XSAVE(JFID)+STDEV*ERG
C
C  LOOP OVER THE FDINT(JJ).
C
      JJ=1
 6030 SGN=RUNIT
      IF(ERG)6040,6700,6050
 6040 SGN=-SGN
 6050 CONTINUE
      WRITE(KW,6060)JFID,STDEV,TOLF,FSAVE,XSAVE(JFID),ERG
 6060 FORMAT(////1X, 'SUBROUTINE FIDO.  COPYRIGHT (C) 1966 ',
     *   'J. P. CHANDLER'//1X, 'JX = ', I2, 10X, 'STDVS = ', E12.5, 
     *   5X, 'TOL = ', E12.5//10X, 'GLOBAL MINIMUM OF FOBJ = ',
     *   E12.5, ' IS AT X(JX) = ', E12.5//10X,
     *   'FIRST GUESS FOR LENGTH OF HALF-INTERVAL = ', E12.5//1X)
C
      KLOSB=0
      MLIN=0
      DO 6070 K=1,NV
 6070   XKA(K)=XSAVE(K)
      FB=FSAVE
      FKA=FSAVE
C
C  BEGIN THE ITERATION LOOP FOR LOCATING THE PLANE PERPENDICULAR TO
C  THE X(JX) AXIS IN WHICH THE MINIMUM VALUE OF FOBJ IS EQUAL TO
C       FPU = FSAVE + STDVS**2  , WHERE FSAVE IS THE VALUE OF FOBJ
C  AT THE GLOBAL MINIMUM.
C
      DO 6660 J=1,NTRY
        FC=FB
        IF(NACTV)6820,6080,6090
 6080   CALL FUNK
        GO TO 6100
 6090   CALL STEPIT(FUNK)
 6100   IF(FOBJ-FBEST)6110,6130,6130
 6110   FBEST=FOBJ
        DO 6120 K=1,NV
 6120     XBEST(K)=X(K)
 6130   DX=X(JFID)-XSAVE(JFID)
        DC=FOBJ-FPU
        WRITE(KW,6140)J,X(JFID),DX,FOBJ,FPU,DC
 6140   FORMAT(//1X, 'ITERATION ', I2/10X, 'X(JX) = ', E18.10, 5X,
     *     'DISTANCE FROM GLOBAL MINIMUM = ', E12.5/10X,
     *     'MINIMUM FOBJ IN THIS PLANE = ', E12.5, 5X,
     *     'VALUE SOUGHT = ', E12.5/10X, 'DIFFERENCE BETWEEN ', 
     *     'MINIMUM FOBJ AND VALUE SOUGHT = ', E12.5)
        IF(FOBJ-FSAVE)6190,6210,6150
C  TEST FOR CONVERGENCE.
C                            IF(ABS(FOBJ-FPU)-TOL)
 6150   DIFF=FOBJ-FPU
        IF(DIFF)6160,6680,6170
 6160   DIFF=-DIFF
 6170   IF(DIFF-TOLF)6680,6680,6180
 6180   IF(FOBJ-FPU)6220,6250,6250
C
 6190   DIFF=FSAVE-FOBJ
        WRITE(KW,6200)DIFF,(X(K),K=1,NV)
 6200   FORMAT(//49H ******** FOBJ LESS THAN VALUE AT INPUT POINT BY ,
     *          E12.5//9X, 23H X(J) AT THIS POINT.... //(1X, 5E23.15))
 6210   FOBJ=FSAVE+RSMAL*(FPU-FSAVE)
C
C  CHECK FOR TIGHTER BRACKETTING OF FPU FROM BELOW.
C
 6220   IF((X(JFID)-XKA(JFID))*SGN)6290,6290,6230
 6230   DO 6240 K=1,NV
 6240     XKA(K)=X(K)
        FKA=FOBJ
        GO TO 6290
C
C  CHECK FOR BRACKETTING OF FPU FROM ABOVE.
C
 6250   IF(KLOSB)6270,6270,6260
 6260   IF((X(JFID)-XKB(JFID))*SGN)6270,6290,6290
 6270   KLOSB=1
        DO 6280 K=1,NV
 6280     XKB(K)=X(K)
        FKB=FOBJ
C
 6290   IF(T(FOBJ)-T(FC))6300,6310,6310
 6300   FB=FOBJ
C
C  CHECK THE RATE OF CONVERGENCE.  IF IT IS SATISFACTORY, AND IF
C  LINEAR INTERPOLATION HAS BEEN USED, USE IT AGAIN.
C
 6310   IF(J-1)6340,6340,6320
 6320   IF(T(FOBJ)-CONV*T(FC))6330,6330,6450
 6330   IF(MLIN)6340,6340,6540
C
C  USE INVERSE PARABOLIC INTERPOLATION.
C
 6340   FAC=STDEV/QSQRT(FOBJ-FSAVE)
C
C                            FAC=AMIN1(FACMX,AMAX1(FAC,1./FACMX))
        IF(FAC-RUNIT/FACMX)6350,6360,6360
 6350   FAC=RUNIT/FACMX
 6360   IF(FAC-FACMX)6380,6380,6370
 6370   FAC=FACMX
 6380   XX=XSAVE(JFID)+FAC*(X(JFID)-XSAVE(JFID))
C
C  CHECK THAT THE PROPOSED POINT IS INSIDE THE BRACKETTED INTERVAL.
C
        IF((XX-XKA(JFID))*SGN)6450,6450,6390
 6390   IF(KLOSB)6410,6410,6400
 6400   IF((XX-XKB(JFID))*SGN)6410,6530,6530
 6410   DO 6440 K=1,NV
          IF(K-JFID)6420,6430,6420
 6420     IF(MASK(K))6440,6430,6440
 6430     X(K)=XSAVE(K)+FAC*(X(K)-XSAVE(K))
 6440     CONTINUE
        GO TO 6660
C
 6450   IF(KLOSB)6460,6460,6530
C
C  CONVERGENCE IS POOR, AND FPU HAS NOT YET BEEN BRACKETTED.
C  TRY TO BRACKET IT.
C
 6460   FRAC=BRACK
        IF(FOBJ-FPU)6480,6470,6470
 6470   FRAC=RUNIT/BRACK
 6480   DO 6510 K=1,NV
          IF(K-JFID)6490,6500,6490
 6490     IF(MASK(K))6510,6500,6510
 6500     X(K)=XSAVE(K)+FRAC*(X(K)-XSAVE(K))
 6510     CONTINUE
        WRITE(KW,6520)
 6520   FORMAT( // 21H BRACKETTING SHOT.... )
        GO TO 6660
C
 6530   IF(MLIN)6540,6540,6600
C
C  TRY LINEAR INTERPOLATION BETWEEN THE TWO BRACKETTING POINTS.
C
 6540   MLIN=1
        FRAC=(FPU-FKA)/(FKB-FKA)
C
C                            FRAC=AMAX1(FRMIN,AMIN1(1.-FRMIN,FRAC))
        IF(FRAC-(RUNIT-FRMIN))6560,6560,6550
 6550   FRAC=RUNIT-FRMIN
 6560   IF(FRAC-FRMIN)6570,6580,6580
 6570   FRAC=FRMIN
 6580   CONTINUE
        WRITE(KW,6590)
 6590   FORMAT( // 25H LINEAR INTERPOLATION.... )
        GO TO 6620
C
C  CONVERGENCE IS POOR, AND LINEAR INTERPOLATION HAS BEEN USED.
C  BISECT THE BRACKETTED INTERVAL.
C
 6600   FRAC=RHALF
        WRITE(KW,6610)
 6610   FORMAT( // 22H INTERVAL BISECTED....  )
C
 6620   DO 6650 K=1,NV
          IF(K-JFID)6630,6640,6630
 6630     IF(MASK(K))6650,6640,6650
 6640     X(K)=XKA(K)+FRAC*(XKB(K)-XKA(K))
 6650     CONTINUE
C
 6660   CONTINUE
C
C  END OF ITERATION LOOP.  THE ITERATION FAILED TO CONVERGE.
C
      WRITE(KW,6670)
 6670 FORMAT( // 40H CONVERGENCE FAILURE IN SUBROUTINE FIDO.  )
      FDINT(JJ)=RZERO
      GO TO 6700
C
C  CONVERGENCE ACHIEVED ...  A SATISFACTORY PLANE HAS BEEN LOCATED.
C
 6680 FDINT(JJ)=X(JFID)-XSAVE(JFID)
      WRITE(KW,6690)JFID,FDINT(JJ),STDEV
 6690 FORMAT(///1X, 'THE LENGTH OF THE CONFIDENCE HALF-INTERVAL FOR ',
     *   'X(', I3, ') = ', E13.5/1X, 'STDVS = ', E12.5//1X)
C
 6700 JJ=JJ+1
      IF(JJ-MXIND)6710,6710,6750
C
C  REFLECT X THROUGH XSAVE, AND SEARCH FOR THE OTHER HALF-INTERVAL.
C
 6710 DO 6740 K=1,NV
        IF(K-JFID)6720,6730,6720
 6720   IF(MASK(K))6740,6730,6740
 6730   X(K)=XSAVE(K)+(XSAVE(K)-X(K))
 6740   CONTINUE
      ERG=X(JFID)-XSAVE(JFID)
      GO TO 6030
C
C  END OF THE JJ LOOP.  PRINT SUMMARY RESULTS.
C
 6750 IF(MXIND-2)6820,6760,6760
 6760 IF(FDINT(1))6770,6820,6780
 6770 IF(FDINT(2))6820,6820,6790
 6780 IF(FDINT(2))6800,6820,6820
 6790 XX=FDINT(1)
      FDINT(1)=FDINT(2)
      FDINT(2)=XX
 6800 XX=-FDINT(2)
      WRITE(KW,6810)FDINT(1),JX,XSAVE(JX),STDEV,XX
 6810 FORMAT(///1X, 'SUMMARY OF RESULTS FROM FIDO....'///35X,
     *   '+', E12.5/9X, ' X(', I3, ') = ', E15.8, 20X,
     *   ' STDVS = ', E12.5/35X, '-', E12.5///1X)
C
C  RESTORE THE SAVED ENTRY VALUES.
C
 6820 DO 6830 J=1,NV
 6830   X(J)=XBEST(J)
      CALL FUNK
      IF(FOBJ-FSAVE)6840,6860,6860
 6840 CONTINUE
      WRITE(KW,6850)FSAVE,FOBJ,(X(J),J=1,NV)
 6850 FORMAT(///1X, 'SUBROUTINE FIDO FOUND A BETTER MINIMUM.'/
     *   1X, 'OLD FOBJ = ', E18.10, 5X, 'NEW FOBJ = ', E18.10, 5X,
     *   'X(J)....'/(1X, 4E18.10))
 6860 MASK(JFID)=MS
      NTRAC=NS
      MATRX=MATS
C
      RETURN
C
C  END FIDO.
      END
